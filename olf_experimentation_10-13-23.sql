-- channel overview latency example
-- to predict how the test impacted GMS, you can apply the latency index to the non mature data. 
-- the code below creates latency estimates based on the average latency curve for us/intl google PLA and how many days have passed since the date. You can layer this into your data by multiplying Att GMS to the latency index for that specfic day. If it's been more than 31 days, default the index to 1 because the data is now mature.
-- We're assuming that the latency curve for this data set looks similar to the average curbe for US/INTL google PLA

with base_data as
(SELECT date, top_channel, sum(attributed_gms) as attributed_gms, sum(attributed_gms_adjusted) as attributed_gms_adjusted
FROM `etsy-data-warehouse-prod.buyatt_rollups.channel_overview` co
left join etsy-data-warehouse-prod.buyatt_mart.channel_dimensions using (top_channel, second_channel, third_channel, utm_campaign, utm_medium)
WHERE co.date >= current_date - 31
and top_channel in ('us_paid','intl_paid')
and reporting_channel_group = 'PLA'
group by 1,2),
sum_base_data as 
  (SELECT
  date_diff(current_date, date, day) as days_since, top_channel, sum(attributed_gms)
  OVER
  (PARTITION BY date, top_channel
  ORDER BY date asc) AS running_sum_attributed_gms,
  sum(attributed_gms_adjusted)
  OVER
  (PARTITION BY date, top_channel
  ORDER BY date asc) AS running_sum_attributed_gms_adjusted,
  FROM base_data)
select days_since, top_channel, running_sum_attributed_gms, running_sum_attributed_gms_adjusted,
safe_divide(running_sum_attributed_gms_adjusted,running_sum_attributed_gms) as latency_index
from sum_base_data
;


begin
DECLARE RUN_DATE_START string default "2023-09-27"; -- SET TO DATE OF RUN
DECLARE RUN_DATE_END string default "2023-09-30"; -- SET TO APPROX. 1 WEEK AFTER RUN_START
DECLARE SEVEN_DAYS_BEFORE_RUN_DATE string default "2023-09-10"; -- SET TO 1 WEEK BEFORE RUN_START
-- get listing ids that would have not been included in the sub-account table, but due to manual rebalancing, were able to be included

create temp table listing_perf_before_after as
(WITH
  Week AS 
  (
  SELECT distinct(offer_id)
  FROM `etsy-data-warehouse-prod.olf.Products_410571163` -- UPDATE TO PROPER MARKET
  WHERE TIMESTAMP_TRUNC  (_PARTITIONTIME, DAY) >= TIMESTAMP(RUN_DATE_START)
    AND TIMESTAMP_TRUNC  (_PARTITIONTIME, DAY) < TIMESTAMP(RUN_DATE_END)
    AND availability = 'in stock'
  ),
  WeekBefore AS 
  (
  SELECT distinct(offer_id)
  FROM `etsy-data-warehouse-prod.olf.Products_410571163` -- UPDATE TO PROPER MARKET
  WHERE TIMESTAMP_TRUNC  (_PARTITIONTIME, DAY) >= TIMESTAMP(SEVEN_DAYS_BEFORE_RUN_DATE) AND TIMESTAMP_TRUNC (_PARTITIONTIME, DAY) < TIMESTAMP(RUN_DATE_START)
  ),
--offer_id is just listing_id in string format with added characters, remove those and convert to int64 here, and get distinct from each table
-- only show me listings that were not in the feed before
listings as 
  (
  SELECT distinct(cast(REGEXP_EXTRACT(Week.offer_id, r'(\d+)') as int64)) AS listing_id
  from Week 
  left join WeekBefore on Week.offer_id = WeekBefore.offer_id
  where WeekBefore.offer_id is null
  )
--join the listing_ids from above to all_transactions to get the transaction_id, then join that to gms_by_trans to get the gms generated by that transaction
select
date,
-- we use the first_page fields from perf_listings_sum because they are indicative of off site traffic that drives immediately to a listing or shop upon a user's first landing 
sum(b.first_page_attr_rev) as attr_rev,
sum(b.first_page_attr_gms) as attr_gms,
sum(b.first_page_visits) as visits
from  `etsy-data-warehouse-prod.rollups.perf_listings_sum` b
join listings using (listing_id)
-- we want to check if more clicks on listings from PLA drives for PLA attributed GMS
where top_channel in ('us_paid','intl_paid')
and (second_channel like '%gpla')
and date >= DATE(SEVEN_DAYS_BEFORE_RUN_DATE)
group by 1);

select *
from listing_perf_before_after;

end;
